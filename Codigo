/*
  Trabalho – Gerenciador de peças com fila circular e pilha

  Funcionalidades:
  - Fila circular de capacidade 5
  - Pilha de capacidade 3
  - Peça: nome ('I','O','T','L') e id único
  - Jogar peça (dequeue)
  - Reservar peça (fila -> pilha)
  - Usar peça reservada (pop pilha)
  - Trocar peça da frente da fila com topo da pilha
  - Troca múltipla: 3 primeiras da fila <-> 3 da pilha
  - Gerar nova peça automaticamente para manter fila cheia (quando possível)
  - Exibir estado atual da fila e da pilha
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM_FILA 5
#define TAM_PILHA 3

/* Struct que representa uma peça do jogo */
typedef struct {
    char nome;  // 'I', 'O', 'T', 'L'
    int id;     // identificador único (ordem de criação)
} Peca;

/* ---------- FILA CIRCULAR ---------- */

typedef struct {
    Peca dados[TAM_FILA];
    int inicio;   // índice do primeiro elemento
    int fim;      // índice da próxima posição livre
    int tamanho;  // quantidade atual de elementos
} Fila;

/* Inicializa a fila vazia */
void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->fim = 0;
    f->tamanho = 0;
}

/* Verifica se a fila está cheia */
int filaCheia(Fila *f) {
    return f->tamanho == TAM_FILA;
}

/* Verifica se a fila está vazia */
int filaVazia(Fila *f) {
    return f->tamanho == 0;
}

/* Insere uma peça no final da fila (enqueue) */
int enfileirar(Fila *f, Peca p) {
    if (filaCheia(f)) {
        return 0; // falha
    }
    f->dados[f->fim] = p;
    f->fim = (f->fim + 1) % TAM_FILA;
    f->tamanho++;
    return 1;
}

/* Remove a peça da frente da fila (dequeue) */
int desenfileirar(Fila *f, Peca *p) {
    if (filaVazia(f)) {
        return 0; // falha
    }
    *p = f->dados[f->inicio];
    f->inicio = (f->inicio + 1) % TAM_FILA;
    f->tamanho--;
    return 1;
}

/* Acessa a peça da frente da fila sem removê-la */
int frenteFila(Fila *f, Peca *p) {
    if (filaVazia(f)) return 0;
    *p = f->dados[f->inicio];
    return 1;
}

/* ---------- PILHA ---------- */

typedef struct {
    Peca dados[TAM_PILHA];
    int topo; // índice do último elemento (topo). -1 se vazia
} Pilha;

/* Inicializa a pilha vazia */
void inicializarPilha(Pilha *p) {
    p->topo = -1;
}

/* Verifica se a pilha está cheia */
int pilhaCheia(Pilha *p) {
    return p->topo == TAM_PILHA - 1;
}

/* Verifica se a pilha está vazia */
int pilhaVazia(Pilha *p) {
    return p->topo == -1;
}

/* Empilha uma peça no topo */
int empilhar(Pilha *p, Peca x) {
    if (pilhaCheia(p)) {
        return 0;
    }
    p->topo++;
    p->dados[p->topo] = x;
    return 1;
}

/* Desempilha uma peça do topo */
int desempilhar(Pilha *p, Peca *x) {
    if (pilhaVazia(p)) {
        return 0;
    }
    *x = p->dados[p->topo];
    p->topo--;
    return 1;
}

/* Consulta peça do topo sem remover */
int topoPilha(Pilha *p, Peca *x) {
    if (pilhaVazia(p)) return 0;
    *x = p->dados[p->topo];
    return 1;
}

/* ---------- GERAÇÃO DE PEÇAS ---------- */

/*
  Gera uma peça automaticamente.
  nome: sorteado entre 'I', 'O', 'T', 'L'
  id: contador global crescente
*/
Peca gerarPeca(int *contadorId) {
    char tipos[] = {'I', 'O', 'T', 'L'};
    int indice = rand() % 4; // 0..3
    Peca p;
    p.nome = tipos[indice];
    p.id = *contadorId;
    (*contadorId)++;
    return p;
}

/* ---------- EXIBIÇÃO DO ESTADO ---------- */

/* Mostra a fila e a pilha de forma legível */
void exibirEstado(Fila *fila, Pilha *pilha) {
    printf("\nEstado atual:\n\n");

    // Fila
    printf("Fila de pecas\t");
    if (filaVazia(fila)) {
        printf("(vazia)");
    } else {
        int idx = fila->inicio;
        for (int i = 0; i < fila->tamanho; i++) {
            Peca p = fila->dados[idx];
            printf("[%c %d] ", p.nome, p.id);
            idx = (idx + 1) % TAM_FILA;
        }
    }
    printf("\n");

    // Pilha
    printf("Pilha de reserva\t(Topo -> base): ");
    if (pilhaVazia(pilha)) {
        printf("(vazia)");
    } else {
        for (int i = pilha->topo; i >= 0; i--) {
            Peca p = pilha->dados[i];
            printf("[%c %d] ", p.nome, p.id);
        }
    }
    printf("\n");
}

/* ---------- AÇÕES DO JOGADOR ---------- */

/*
  Jogar uma peça:
  - remove da frente da fila
  - NÃO volta pro jogo
  - gera nova peça para manter fila cheia (se conseguir)
*/
void acaoJogarPeca(Fila *fila, int *contadorId) {
    Peca removida;
    if (!desenfileirar(fila, &removida)) {
        printf("Nao ha pecas na fila para jogar.\n");
        return;
    }
    printf("Peca jogada: [%c %d]\n", removida.nome, removida.id);

    // Gera nova peça para manter a fila cheia (quando possível)
    if (!filaCheia(fila)) {
        Peca nova = gerarPeca(contadorId);
        enfileirar(fila, nova);
        printf("Nova peca gerada e adicionada a fila: [%c %d]\n",
               nova.nome, nova.id);
    }
}

/*
  Reservar uma peça:
  - pega a peça da frente da fila
  - remove da fila
  - coloca no topo da pilha (se houver espaço)
  - gera nova peça para manter a fila cheia
*/
void acaoReservarPeca(Fila *fila, Pilha *pilha, int *contadorId) {
    if (pilhaCheia(pilha)) {
        printf("Pilha de reserva cheia. Nao e possivel enviar mais pecas.\n");
        return;
    }
    Peca frente;
    if (!desenfileirar(fila, &frente)) {
        printf("Fila vazia. Nao ha peca para reservar.\n");
        return;
    }
    if (!empilhar(pilha, frente)) {
        printf("Erro ao empilhar peca na reserva.\n");
        // se falhar empilhar (quase impossível aqui), peça some do jogo
    } else {
        printf("Peca [%c %d] enviada para a pilha de reserva.\n",
               frente.nome, frente.id);
    }

    // Gerar nova peça para a fila
    if (!filaCheia(fila)) {
        Peca nova = gerarPeca(contadorId);
        enfileirar(fila, nova);
        printf("Nova peca gerada e adicionada a fila: [%c %d]\n",
               nova.nome, nova.id);
    }
}

/*
  Usar uma peça reservada:
  - tira do topo da pilha
  - não volta pro jogo
*/
void acaoUsarReservada(Pilha *pilha) {
    Peca usada;
    if (!desempilhar(pilha, &usada)) {
        printf("Nao ha pecas reservadas para usar.\n");
        return;
    }
    printf("Peca reservada usada: [%c %d]\n", usada.nome, usada.id);
}

/*
  Trocar peça da frente da fila com o topo da pilha.
*/
void acaoTrocarFrenteComTopo(Fila *fila, Pilha *pilha) {
    if (filaVazia(fila)) {
        printf("Fila vazia. Nao ha peca para trocar.\n");
        return;
    }
    if (pilhaVazia(pilha)) {
        printf("Pilha vazia. Nao ha peca reservada para trocar.\n");
        return;
    }

    int idxFrente = fila->inicio;
    int idxTopo = pilha->topo;

    Peca temp = fila->dados[idxFrente];
    fila->dados[idxFrente] = pilha->dados[idxTopo];
    pilha->dados[idxTopo] = temp;

    printf("Troca realizada entre frente da fila e topo da pilha.\n");
}

/*
  Troca múltipla:
  - Alterna as 3 primeiras peças da fila com as 3 da pilha
  - Só ocorre se fila tiver pelo menos 3 e pilha tiver 3
*/
void acaoTrocaMultipla(Fila *fila, Pilha *pilha) {
    if (fila->tamanho < 3) {
        printf("Fila nao possui 3 pecas para troca multipla.\n");
        return;
    }
    if (pilha->topo < 2) { // topo = 2 => 3 elementos (0,1,2)
        printf("Pilha nao possui 3 pecas para troca multipla.\n");
        return;
    }

    // Índices das 3 primeiras posições da fila
    int idxFila0 = fila->inicio;
    int idxFila1 = (fila->inicio + 1) % TAM_FILA;
    int idxFila2 = (fila->inicio + 2) % TAM_FILA;

    // Trocar fila[0..2] com pilha[topo..topo-2]
    for (int i = 0; i < 3; i++) {
        int idxFila = (fila->inicio + i) % TAM_FILA;
        int idxPilha = pilha->topo - i;

        Peca tmp = fila->dados[idxFila];
        fila->dados[idxFila] = pilha->dados[idxPilha];
        pilha->dados[idxPilha] = tmp;
    }

    printf("Ação: troca multipla realizada entre os 3 primeiros da fila e as 3 pecas da pilha.\n");
}

/* ---------- MENU ---------- */

void mostrarMenu() {
    printf("\nOpcoes disponiveis:\n");
    printf("1 - Jogar peca da frente da fila\n");
    printf("2 - Enviar peca da fila para a pilha de reserva\n");
    printf("3 - Usar peca da pilha de reserva\n");
    printf("4 - Trocar peca da frente da fila com o topo da pilha\n");
    printf("5 - Trocar os 3 primeiros da fila com as 3 pecas da pilha\n");
    printf("0 - Sair\n");
    printf("Escolha uma opcao: ");
}

/* ---------- MAIN ---------- */

int main() {
    Fila fila;
    Pilha pilha;
    int contadorId = 0; // controla id único das peças
    int opcao;

    srand((unsigned int)time(NULL));

    inicializarFila(&fila);
    inicializarPilha(&pilha);

    // Inicializar fila com 5 peças (sempre cheia no começo)
    for (int i = 0; i < TAM_FILA; i++) {
        Peca nova = gerarPeca(&contadorId);
        enfileirar(&fila, nova);
    }

    printf("Gerenciador de pecas iniciado.\n");
    exibirEstado(&fila, &pilha);

    do {
        mostrarMenu();
        if (scanf("%d", &opcao) != 1) {
            // entrada inválida -> limpa buffer e segue
            int c;
            while ((c = getchar()) != '\n' && c != EOF) {}
            printf("Opcao invalida.\n");
            continue;
        }

        switch (opcao) {
            case 1:
                printf("\nAcao: Jogar peca da frente da fila\n");
                acaoJogarPeca(&fila, &contadorId);
                exibirEstado(&fila, &pilha);
                break;

            case 2:
                printf("\nAcao: Enviar peca da fila para a pilha de reserva\n");
                acaoReservarPeca(&fila, &pilha, &contadorId);
                exibirEstado(&fila, &pilha);
                break;

            case 3:
                printf("\nAcao: Usar peca da pilha de reserva\n");
                acaoUsarReservada(&pilha);
                exibirEstado(&fila, &pilha);
                break;

            case 4:
                printf("\nAcao: Trocar frente da fila com topo da pilha\n");
                acaoTrocarFrenteComTopo(&fila, &pilha);
                exibirEstado(&fila, &pilha);
                break;

            case 5:
                printf("\nAcao: Troca multipla (3 da fila <-> 3 da pilha)\n");
                acaoTrocaMultipla(&fila, &pilha);
                exibirEstado(&fila, &pilha);
                break;

            case 0:
                printf("Encerrando o programa...\n");
                break;

            default:
                printf("Opcao invalida.\n");
        }

    } while (opcao != 0);

    return 0;
}
